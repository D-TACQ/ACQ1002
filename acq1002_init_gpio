#!/bin/sh

mkdir -p /dev/gpio
cd /sys/class/gpio

export_gpio() {
	#echo export_gpio $1
	echo $1 > export
}

getchip() {
	addr=$1
	ls -l gpiochip* | grep $addr | awk '{ print $9 }'
}

setHI() {
	echo 1 > $1
}

setLO() {
	echo 0 > $1
}

setO() {
	#echo setO $1
	echo out >$1/direction
}
setAL() {
	echo 1 >$1/active_low
	if [ "$(cat $1/direction)" = "out" ]; then
		echo 0 >$1/value
	fi
}
mkln() {
	ln -s $PWD/$1/value /dev/gpio/$2
	if [ "x$3" = "xAL" ]; then
		setAL $1
	fi
}


i2c_reset() {
	setHI /dev/gpio/I2C_RESET
	sleep 0.1
	setLO /dev/gpio/I2C_RESET
	echo +++ I2C_RESET done
}


# Zynq GPIO
export_gpio  0; setO gpio0
export_gpio 47;

mkln gpio0 LED_ACT
nice daemon /usr/local/bin/heartbeat

#export_gpio  9; setO gpio9
#mkln gpio9 I2C_RESET AL
#i2c_reset

mkln gpio47 EXT_WP AL


# i2c gpio

get_gpiochip() 
{
	echo $(basename $(echo /sys/bus/i2c/devices/$1-$2/gpio/gpiochip*))	
}





CHIP122=$(get_gpiochip 1 0022) 
let GPIO_MB1=${CHIP122#gpiochip*}
let GPIO_MB2=$GPIO_MB1+23

CHIP123=$(get_gpiochip 1 0023)
let GPIO_XX1=${CHIP123#gpiochip*}
let GPIO_XX2=$GPIO_XX1+23
let GPIO_XXO2=$GPIO_XX1+14

CHIP420=$(get_gpiochip 4 0020)
let GPIO_CELF1=${CHIP420#gpiochip*}
let GPIO_CELF2=$GPIO_CELF1+1

for pin in $(seq $GPIO_MB1 $GPIO_MB2) $(seq $GPIO_XX1 $GPIO_XX2) \
		$(seq $GPIO_CELF1 $GPIO_CELF2)
do
	export_gpio $pin
done




for pin in $(seq $GPIO_MB1 $GPIO_MB2) $(seq $GPIO_XX1 $GPIO_XXO2) \
	$(seq $GPIO_CELF1 $GPIO_CELF2)	  
do
	setO gpio$pin
done


mkdir -p /dev/gpio/CLK/MB/RDW
let MBX=$GPIO_MB1
mkln gpio$MBX CLK/MB/RDW/R6; let MBX=$MBX+1
mkln gpio$MBX CLK/MB/RDW/R5; let MBX=$MBX+1
mkln gpio$MBX CLK/MB/RDW/R4; let MBX=$MBX+1
mkln gpio$MBX CLK/MB/RDW/R3; let MBX=$MBX+1
mkln gpio$MBX CLK/MB/RDW/R2; let MBX=$MBX+1
mkln gpio$MBX CLK/MB/RDW/R1; let MBX=$MBX+1
mkln gpio$MBX CLK/MB/RDW/R0; let MBX=$MBX+1

mkdir /dev/gpio/CLK/MB/FDW
mkln gpio$MBX CLK/MB/FDW/F6; let MBX=$MBX+1
mkln gpio$MBX CLK/MB/FDW/F5; let MBX=$MBX+1
mkln gpio$MBX CLK/MB/FDW/F4; let MBX=$MBX+1
mkln gpio$MBX CLK/MB/FDW/F3; let MBX=$MBX+1
mkln gpio$MBX CLK/MB/FDW/F2; let MBX=$MBX+1
mkln gpio$MBX CLK/MB/FDW/F1; let MBX=$MBX+1
mkln gpio$MBX CLK/MB/FDW/F0; let MBX=$MBX+1

mkdir /dev/gpio/CLK/MB/ODW
mkln gpio$MBX CLK/MB/ODW/S1; let MBX=$MBX+1
mkln gpio$MBX CLK/MB/ODW/S0; let MBX=$MBX+1


gpioXXX() {
	let lgp=$GPIO_XX1+$1
	echo gpio$lgp
}


mkdir -p /dev/gpio/LED
mkln $(gpioXXX  0) LED/FMC1_G 	AL
mkln $(gpioXXX  1) LED/FMC1_R 	AL
mkln $(gpioXXX  2) LED/TRG_G 		AL
mkln $(gpioXXX  3) LED/TRG_R 		AL
mkln $(gpioXXX  4) LED/CLK_G 		AL
mkln $(gpioXXX  5) LED/CLK_R 		AL

mkln $(gpioXXX  6) CLK/SYNC_SET_OUT	
mkln $(gpioXXX  7) CLK/SYNC_SET_IN	AL
mkln $(gpioXXX  8) CLK/MB/ICS_CLK2_OE
mkln $(gpioXXX  9) CLK/OSC_X_OE 	AL
mkln $(gpioXXX 10) CLK/OSC_X_CLK_OE	AL
mkln $(gpioXXX 11) CLK/FP_CLK_OE 	AL
mkln $(gpioXXX 12) CLK/FP_OE		AL
mkln $(gpioXXX 13) 15VA_EN		AL
mkln $(gpioXXX 14) Si570_OE

mkln $(gpioXXX 16) fmc1_present		AL
mkln $(gpioXXX 17) fmc2_present		AL
mkln $(gpioXXX 18) celf_prsnt		AL
mkln $(gpioXXX 19) mcvt_prsnt		AL
mkln $(gpioXXX 20) BV_FMC
mkln $(gpioXXX 21) BV2
mkln $(gpioXXX 22) BV3
mkln $(gpioXXX 23) BV4 

gpioCELFX() {
	let lgp=$GPIO_CELF1+$1
	echo gpio$lgp	
}

mkln $(gpioCELFX 0)	LED/FMC2_G	AL
mkln $(gpioCELFX 1)	LED/FMC2_R	AL
  
	
clear_leds() {	
	for LED in /dev/gpio/LED/*
	do
		echo 0 > $LED
	done
}

test_leds() {
	for LED in /dev/gpio/LED/*
	do
		setHI $LED
		sleep 0.2
		setLO $LED
	done
}
	
clear_leds
test_leds


# OK, this isn't gpio, but it's handy to put it here:

mkdir -p /dev/hwmon

for S in 0 1 2 3 4
do
	SRC=/sys/class/hwmon/hwmon${S}/device
	if [ -e ${SRC}/temp ]; then
		ID=Z
	else
		ID=$S	
	fi
	DST=/dev/hwmon/${ID}
	mkdir $DST
	
	case ${ID} in
	Z)
		for xx in temp v v_mode vccaux vccbram vccint
		do
			ln -s ${SRC}/${xx} ${DST}/${xx}
		done;;			
	0)
		ln -s ${SRC}/temp1_input ${DST}/temp
		ln -s ${SRC}/in1_input	 ${DST}/15VA_N
		ln -s ${SRC}/in2_input	 ${DST}/15VA_P
		ln -s ${SRC}/in3_input	 ${DST}/5V_P
		ln -s ${SRC}/in4_input	 ${DST}/VADJ;;
	*)
		ln -s ${SRC}/temp1_input ${DST}/temp
		for xx in in1_input in2_input in3_input in4_input
		do
			ln -s ${SRC}/${xx} ${DST}/${xx%*_input}
		done;;
	esac					
done

